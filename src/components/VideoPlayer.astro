---
import type { ImageMetadata } from 'astro';

// Define expected video sources
interface VideoSources {
  mp4: string; // Make mp4 required as per current usage
  webm?: string;
  // Add other formats like ogv if needed
}

// Define component props
interface Props {
  sources: VideoSources; // The video files
  thumbnail: ImageMetadata; // Renamed from posterImage, made required
  alt: string; // Alt text for accessibility - Made required again
}

const { sources, thumbnail, alt } = Astro.props; // Update destructuring

// Get the thumbnail image path
const thumbnailPath = thumbnail.src; // Update variable name and usage

// Generate a unique ID for this video instance to help script targeting
const videoId = `video-${crypto.randomUUID()}`;
---

<div class="video-wrapper">
  <video
    id={videoId}
    autoplay
    muted
    loop
    playsinline
    poster={thumbnailPath}
    preload="metadata"
    width="100%"
    height="auto"
    class="artwork-video"
    aria-label={alt}
  >
    {sources.webm && <source src={sources.webm} type="video/webm" />}
    {sources.mp4 && <source src={sources.mp4} type="video/mp4" />}
    Your browser does not support the video tag.
  </video>
</div>

<script>
  // This script will run for each VideoPlayer instance.
  const currentScript = document.currentScript;
  const videoWrapper = currentScript?.closest('.video-wrapper');
  const videoElement = videoWrapper?.querySelector('video.artwork-video') as HTMLVideoElement | null;

  if (videoElement) {
    // Assuming Astro handles script execution context correctly (usually runs once per instance)
    // Removed the _observerAttached check for simplicity

    const observerOptions = {
      root: null,
      rootMargin: '0px',
      threshold: 0.1 // 10% visible
    };

    const observerCallback = (entries: IntersectionObserverEntry[]) => {
      entries.forEach(entry => {
        const targetVideo = entry.target as HTMLVideoElement;
        if (entry.isIntersecting) {
          if (targetVideo.paused) {
            targetVideo.play().catch(error => {
              console.error("Video play failed:", error, targetVideo);
            });
          }
        } else {
          if (!targetVideo.paused) {
            targetVideo.pause();
          }
        }
      });
    };

    const observer = new IntersectionObserver(observerCallback, observerOptions);
    observer.observe(videoElement);

    // Optional cleanup logic remains here if needed

  } else {
    console.error('VideoPlayer script: Could not find associated video element.');
  }
</script>

<style>
  /* Style the wrapper if needed, otherwise it's just for script targeting */
  .video-wrapper {
    margin-bottom: 0.8rem; /* Move margin from video to wrapper */
  }
  .artwork-video {
    display: block;
    width: 100%;
    height: auto;
    /* margin-bottom removed, handled by wrapper */
    background-color: #f0f0f0;
  }
</style> 