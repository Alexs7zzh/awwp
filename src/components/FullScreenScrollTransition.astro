---
import { Picture } from 'astro:assets';
import type { ImageMetadata } from 'astro';

type Props = {
  images: {
    src: ImageMetadata;
    alt: string;
  }[];
};

const { images } = Astro.props;

// Separate the last image from the transition images
const transitionImages = images.slice(0, -1);
const lastImage = images.length > 0 ? images[images.length - 1] : null;
---

<div class="scroll-container">
  {/* Fixed transition container for all images */}
  <div class="transition-container">
    {images.map((image, index) => (
      <div class="image-layer" data-index={index}>
        <Picture 
          src={image.src} 
          alt={image.alt} 
          formats={['avif', 'webp']} 
          widths={[360, 480, 720, 1024, 1920, 2048]} 
          sizes="100vw"
          loading={index === 0 ? "eager" : "lazy"}
        />
      </div>
    ))}
  </div>
  
  {/* Spacer to create scroll space for transition images */}
  <div class="transition-spacer"></div>
  
  {/* Last image as a normal document flow element */}
  {lastImage && (
    <div class="last-image">
      <Picture 
        src={lastImage.src} 
        alt={lastImage.alt} 
        formats={['avif', 'webp']} 
        widths={[360, 480, 720, 1024, 1920, 2048]} 
        sizes="100vw"
        loading="lazy"
      />
    </div>
  )}
</div>

<style>
  .scroll-container {
    position: relative;
    width: 100%;
    background: black;
  }

  .transition-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    z-index: 10;
  }

  .image-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    transition: opacity 0.2s ease-out;
  }

  .image-layer:first-child {
    opacity: 1;
  }

  .image-layer img,
  .last-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .transition-spacer {
    height: calc(100vh * var(--transition-sections, 1));
  }

  .last-image {
    position: relative;
    width: 100%;
    height: 100vh;
  }
</style>

<script>
  const container = document.querySelector('.scroll-container') as HTMLElement;
  const transitionContainer = document.querySelector('.transition-container') as HTMLElement;
  const transitionImages = document.querySelectorAll('.image-layer') as NodeListOf<HTMLElement>;
  const totalTransitionImages = transitionImages.length;
  const lastNormalImage = document.querySelector('.last-image') as HTMLElement;
  
  // Index of the last image in the transition container
  const lastImageIndex = totalTransitionImages - 1;
  
  // Constants for controlling the scroll behavior
  const STATIC_PHASE = 0.7; // 70% of scroll distance is static (opacity = 1)
  const TRANSITION_PHASE = 0.3; // 30% is transition phase
  
  // Calculate section heights
  const sectionHeight = window.innerHeight; // Each image section is full viewport height
  
  // Set the total height for scrolling - we need one less viewport height
  // since the last image is both in the transition and normal flow
  const spacer = document.querySelector('.transition-spacer') as HTMLElement;
  if (spacer) {
    spacer.style.setProperty('--transition-sections', String(totalTransitionImages - 1));
  }
  
  function updateScroll() {
    if (!container || !transitionContainer || totalTransitionImages === 0) return;
    
    // Guard against negative scroll values (overscroll up)
    const scrollTop = Math.max(0, window.scrollY);
    
    // Calculate which section we're in
    const currentSection = Math.min(Math.floor(scrollTop / sectionHeight), totalTransitionImages - 1);
    
    // Calculate how far we are through the current section (0 to 1)
    const sectionProgress = (scrollTop % sectionHeight) / sectionHeight;
    
    // Determine if we should transition to the next image
    const inTransitionPhase = sectionProgress > STATIC_PHASE;
    
    // Calculate the transition progress (0 to 1) if in transition phase
    const transitionProgress = inTransitionPhase 
      ? (sectionProgress - STATIC_PHASE) / TRANSITION_PHASE 
      : 0;
    
    // Calculate when the transition to the last image is complete
    const secondToLastImageIndex = totalTransitionImages - 2;
    const lastImageTransitionStart = sectionHeight * secondToLastImageIndex + (STATIC_PHASE * sectionHeight);
    const lastImageTransitionEnd = lastImageTransitionStart + (TRANSITION_PHASE * sectionHeight);
    
    // Check if we're showing the last image and it's fully visible
    const isLastImageFullyVisible = currentSection === lastImageIndex && !inTransitionPhase;
    
    // Check if we've passed the point where the last image is fully transitioned in
    const pastLastImageTransition = scrollTop >= lastImageTransitionEnd;
    
    // Handle transition container visibility
    if (pastLastImageTransition) {
      // Once the last image is fully visible, hide the transition container
      // This should be unnoticeable as the normal flow image is now visible
      transitionContainer.style.opacity = '0';
      transitionContainer.style.visibility = 'hidden';
      transitionContainer.style.pointerEvents = 'none';
      
      // Make sure normal flow image is fully visible
      if (lastNormalImage) {
        lastNormalImage.style.opacity = '1';
      }
    } else {
      // Normal transition behavior
      transitionContainer.style.opacity = '1';
      transitionContainer.style.visibility = 'visible';
      transitionContainer.style.pointerEvents = 'auto';
      
      // Show the normal flow last image during the last transition
      if (lastNormalImage) {
        if (currentSection === secondToLastImageIndex && inTransitionPhase) {
          // Fade in the normal image as we transition to the last image
          lastNormalImage.style.opacity = String(transitionProgress);
        } else {
          lastNormalImage.style.opacity = '0';
        }
      }
    }
    
    // Update image opacities in the transition container
    transitionImages.forEach((img, i) => {
      if (i < currentSection) {
        // Images we've scrolled past
        img.style.opacity = '0';
      } else if (i === currentSection) {
        // Current image - fade out if in transition phase
        img.style.opacity = inTransitionPhase 
          ? String(1 - transitionProgress) 
          : '1';
      } else if (i === currentSection + 1 && inTransitionPhase) {
        // Next image - fade in if in transition phase
        img.style.opacity = String(transitionProgress);
      } else {
        // Future images
        img.style.opacity = '0';
      }
    });
  }

  // Set up event listeners
  window.addEventListener('scroll', updateScroll);
  window.addEventListener('resize', updateScroll);
  
  // Initial update
  updateScroll();
</script>