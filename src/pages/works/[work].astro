---
import BaseLayout from "@layouts/BaseLayout.astro";
import { marked } from "marked";
import { getCollection } from "astro:content";
import { imageStore } from "@lib/imageStore";
import { Picture } from "astro:assets";

export async function getStaticPaths() {
  const works = await getCollection("work");
  return works.map((entry) => ({
    params: { work: entry.id },
    props: entry,
  }));
}

const gridCols = 2;

// Reuse your page spacing from Config (fallbacks keep things resilient)
const pageVMargin = "2rem";
const pageHMargin = "2rem";

// Sensible defaults for multi-column gaps (theme can override later)
const multiRowGap = "clamp(2.5rem, 6vw, 6rem)";
const multiColGap = "3rem";

// Define max content width (can be pulled from Config if added there later)
const maxContentWidth = "800px";

const work = Astro.props;

// Get image records to access IDs for pinning
const imageRecords = imageStore.requireByWork(work.id);

// Extract pinned IDs
const pinSet = new Set((work.data.pin ?? []).map((id) => id.trim()));

// Filter pinned and unpinned records
const pinnedRecords = imageRecords.filter((r) => pinSet.has(r.id));
const unpinnedRecords = imageRecords.filter((r) => !pinSet.has(r.id));

// Map to metadata for rendering
const pinnedImages = pinnedRecords.map((r) => r.metadata);
const unpinnedImages = unpinnedRecords.map((r) => r.metadata);

// Normalize keywords to an array
const keywordsRaw = work.data.keywords ?? [];
const keywords = Array.isArray(keywordsRaw)
  ? keywordsRaw
  : String(keywordsRaw)
      .split(",")
      .map((k) => k.trim())
      .filter(Boolean);

const firstPinned = pinnedImages.length > 0 ? pinnedImages[0] : null;
const remainingPinned = pinnedImages.slice(1);
---

<BaseLayout title=`Akira Wakita - ${work.data.title}`>
  <article>
    <header class="work-hero" aria-labelledby="work-title">
      <h1 id="work-title" class="text-block-title">{work.data.title}</h1>

      <div class="meta-stack">
        {work.data.year && <p class="meta-year meta-item">{work.data.year}</p>}

        {
          keywords.length > 0 && (
            <p class="meta-keywords meta-item">{keywords.join(", ")}</p>
          )
        }
      </div>
    </header>
    <!-- First pinned image before header -->
    {
      firstPinned && (
        <div
          class="work-grid pinned hero"
          style={`
        --grid-columns: 1;
        --page-vmargin: ${pageVMargin};
        --page-hmargin: ${pageHMargin};
        --multi-row-gap: ${multiRowGap};
        --multi-col-gap: ${multiColGap};
      `}
        >
          {(() => {
            const src =
              typeof firstPinned === "string"
                ? firstPinned
                : (firstPinned?.src ?? "");
            const alt = `${work.data.title} — image 1`;
            return (
              <div class="grid-item">
                <a
                  href={src}
                  aria-label={`Open image 1 for ${work.data.title}`}
                >
                  <div class="image-wrapper">
                    <Picture
                      src={firstPinned}
                      alt={alt}
                      formats={["avif", "webp"]}
                      widths={[600, 1200, 1800]}
                      sizes="(min-width: 1220px) 1200px, 100vw"
                      class="list-image"
                      loading="lazy"
                      fetchpriority="auto"
                    />
                  </div>
                </a>
              </div>
            );
          })()}
        </div>
      )
    }

    {
      work.data.description_jp && (
        <div
          class="text-block-content intro"
          set:html={marked.parse(work.data.description_jp)}
        />
      )
    }

    <div
      class="text-block-content"
      set:html={marked.parse(work.data.meta_jp)}
    />

    <!-- Remaining pinned images grid (always 1 column) -->
    {
      remainingPinned.length > 0 && (
        <div
          class="work-grid pinned"
          style={`
        --grid-columns: 1;
        --page-vmargin: ${pageVMargin};
        --page-hmargin: ${pageHMargin};
        --multi-row-gap: ${multiRowGap};
        --multi-col-gap: ${multiColGap};
      `}
        >
          {remainingPinned.map((img, i) => {
            const src = typeof img === "string" ? img : (img?.src ?? "");
            const alt = `${work.data.title} — image ${i + 2}`;
            return (
              <div class="grid-item">
                <a
                  href={src}
                  aria-label={`Open image ${i + 2} for ${work.data.title}`}
                >
                  <div class="image-wrapper">
                    <Picture
                      src={img}
                      alt={alt}
                      formats={["avif", "webp"]}
                      widths={[600, 1200, 1800]}
                      sizes="(min-width: 1220px) 1200px, 100vw"
                      class="list-image"
                      loading="lazy"
                      fetchpriority="auto"
                    />
                  </div>
                </a>
              </div>
            );
          })}
        </div>
      )
    }

    <!-- Unpinned images grid -->
    {
      unpinnedImages.length > 0 && (
        <div
          class="work-grid"
          style={`
        --grid-columns: ${gridCols};
        --page-vmargin: ${pageVMargin};
        --page-hmargin: ${pageHMargin};
        --multi-row-gap: ${multiRowGap};
        --multi-col-gap: ${multiColGap};
      `}
        >
          {unpinnedImages.map((img, i) => {
            const src = typeof img === "string" ? img : (img?.src ?? "");
            const alt = `${work.data.title} — image ${i + 1}`;
            return (
              <div class="grid-item">
                <a
                  href={src}
                  aria-label={`Open image ${i + 1} for ${work.data.title}`}
                >
                  <div class="image-wrapper">
                    <Picture
                      src={img}
                      alt={alt}
                      formats={["avif", "webp"]}
                      widths={[400, 800, 1200]}
                      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                      class="list-image"
                      loading="lazy"
                      fetchpriority="auto"
                    />
                  </div>
                </a>
              </div>
            );
          })}
        </div>
      )
    }

    {
      work.data.footer && (
        <div
          class="text-block-content footer"
          set:html={marked.parse(work.data.footer)}
        />
      )
    }
  </article>
</BaseLayout>

<style>
  article {
    padding: 0 var(--page-padding);
  }

  .work-hero {
    padding-top: clamp(2rem, 6vw, 6rem);
    color: var(--font-color-body);
  }

  .text-block-title {
    color: var(--font-color-title);
    display: inline-block;
    position: relative;
    padding-bottom: 2px;
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.18em;
    font-weight: 400;
    margin: 0;
  }

  .meta-stack {
    margin-top: 0.5rem;
    margin-bottom: 2.4rem;
    font-size: 0.8rem;
  }

  .meta-item {
    margin: 0;
    font-weight: 300;
    color: var(--font-color-body);
  }

  .meta-year {
    letter-spacing: 0.08em;
  }

  .meta-keywords {
    letter-spacing: 0.14em;
    text-transform: uppercase;
    margin-top: 0.2rem;
  }

  .text-block-content {
    color: var(--font-color-body);
    font-weight: 300;
    font-size: 1rem;
    line-height: 1.6;
  }
  .text-block-content :global(p) {
    line-height: 1.7;
    margin: 0;
  }
  .text-block-content :global(p + p) {
    margin-block-start: 1.6em;
  }
  .text-block-content :global(h2) {
    font-size: 1rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    font-weight: 300;
    margin-top: 2rem;
    color: var(--font-color-title);
  }
  .text-block-content :global(h3) {
    font-size: 1rem;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    font-weight: 300;
    margin-top: 1.5rem;
    color: var(--font-color-title);
  }
  .text-block-content :global(ul, ol, blockquote) {
    margin-block: 1rem;
  }

  /* Image grid */
  .work-grid {
    margin: clamp(4rem, 12vw, 10rem) auto;
    display: grid;
    grid-template-columns: repeat(var(--grid-columns, 1), minmax(0, 1fr));
    row-gap: var(--multi-row-gap, clamp(2.5rem, 6vw, 6rem));
    column-gap: var(--multi-col-gap, 3rem);
    align-items: end;
  }

  /* When pinned (1 column): reuse your page "heighting" rhythm from Config. */
  .work-grid.pinned {
    row-gap: var(--page-vmargin, 2rem);
    column-gap: var(--page-hmargin, 2rem);
  }

  /* Hero pinned image adjustments */
  .work-grid.pinned.hero {
    margin: 0 auto clamp(2rem, 6vw, 6rem) auto;
  }

  /* Reduce margin between pinned and unpinned grids */
  .work-grid.pinned + .work-grid {
    margin-top: clamp(2.5rem, 6vw, 6rem);
  }

  .grid-item a {
    display: flex;
    flex-direction: column;
    text-decoration: none;
    color: inherit;
    transition: opacity 0.2s ease;
  }
  .grid-item a:hover {
    opacity: 0.96;
  }

  .image-wrapper {
    position: relative;
    overflow: hidden;
    border-radius: 0;
  }
  .list-image {
    display: block;
    width: 100%;
    height: auto;
  }

  /* Footer section */
  .text-block-content.footer {
    margin: 0 auto 20vh;
    padding: 0 2rem;
  }
</style>
