---
import BaseLayout from "@layouts/BaseLayout.astro";
import { marked } from "marked";
import { getCollection } from "astro:content";
import { imageStore } from "@lib/imageStore";
import { Config } from "@config";
import { Picture } from "astro:assets";

export async function getStaticPaths() {
  const works = await getCollection("work");
  return works.map((entry) => ({
    params: { work: entry.id },
    props: entry,
  }));
}

const rawCols = Number(Config.detailPage.column ?? 1);
const gridCols =
  Number.isFinite(rawCols) && rawCols > 0 ? Math.floor(rawCols) : 1;

// Reuse your page spacing from Config (fallbacks keep things resilient)
const pageVMargin = "2rem";
const pageHMargin = "2rem";

// Sensible defaults for multi-column gaps (theme can override later)
const multiRowGap = "clamp(2.5rem, 6vw, 6rem)";
const multiColGap = "3rem";

// Define max content width (can be pulled from Config if added there later)
const maxContentWidth = "1200px";

const work = Astro.props;

// Get image records to access IDs for pinning
const imageRecords = imageStore.requireByWork(work.id);

// Extract pinned IDs
const pinSet = new Set((work.data.pin ?? []).map((id) => id.trim()));

// Filter pinned and unpinned records
const pinnedRecords = imageRecords.filter((r) => pinSet.has(r.id));
const unpinnedRecords = imageRecords.filter((r) => !pinSet.has(r.id));

// Map to metadata for rendering
const pinnedImages = pinnedRecords.map((r) => r.metadata);
const unpinnedImages = unpinnedRecords.map((r) => r.metadata);

// Normalize keywords to an array
const keywordsRaw = work.data.keywords ?? [];
const keywords = Array.isArray(keywordsRaw)
  ? keywordsRaw
  : String(keywordsRaw)
      .split(",")
      .map((k) => k.trim())
      .filter(Boolean);
---

<BaseLayout>
  <article class="work theme-compact-gallery" style={`--max-content-width: ${maxContentWidth};`}>
    <!-- Hero -->
    <header class="work-hero" aria-labelledby="work-title">
      <h1 id="work-title" class="text-block-title">{work.data.title}</h1>

      <div class="work-hero__left">
        <div class="meta-stack">
          {work.data.year && <p class="meta-item">{work.data.year}</p>}

          {
            keywords.length > 0 && (
              <ul class="meta-tags" role="list">
                {keywords.map((k) => (
                  <li class="meta-tag">{k}</li>
                ))}
              </ul>
            )
          }
        </div>

        <div
          class="text-block-content"
          set:html={marked.parse(work.data.meta_jp)}
        />
      </div>

      <div class="work-hero__right">
        {
          work.data.description_jp && (
            <div
              class="text-block-content intro"
              set:html={marked.parse(work.data.description_jp)}
            />
          )
        }
      </div>
    </header>

    <!-- Pinned images grid (always 1 column) -->
    {
      pinnedImages.length > 0 && (
        <ul
          class="work-grid pinned"
          role="list"
          data-cols={1}
          style={`
        --grid-columns: 1;
        --page-vmargin: ${pageVMargin};
        --page-hmargin: ${pageHMargin};
        --multi-row-gap: ${multiRowGap};
        --multi-col-gap: ${multiColGap};
      `}
        >
          {pinnedImages.map((img, i) => {
            const src = typeof img === "string" ? img : (img?.src ?? "");
            const alt = `${work.data.title} — image ${i + 1}`;
            return (
              <li class="grid-item">
                <a
                  href={src}
                  aria-label={`Open image ${i + 1} for ${work.data.title}`}
                >
                  <div class="image-wrapper">
                    <Picture
                      src={img}
                      alt={alt}
                      formats={["avif", "webp"]}
                      widths={[600, 1200, 1800]}
                      sizes="(min-width: 1220px) 1200px, 100vw"
                      class="list-image"
                      loading="lazy"
                      fetchpriority="auto"
                    />
                  </div>
                </a>
              </li>
            );
          })}
        </ul>
      )
    }

    <!-- Unpinned images grid -->
    {
      unpinnedImages.length > 0 && (
        <ul
          class="work-grid"
          role="list"
          data-cols={gridCols}
          style={`
        --grid-columns: ${gridCols};
        --page-vmargin: ${pageVMargin};
        --page-hmargin: ${pageHMargin};
        --multi-row-gap: ${multiRowGap};
        --multi-col-gap: ${multiColGap};
      `}
        >
          {unpinnedImages.map((img, i) => {
            const src = typeof img === "string" ? img : (img?.src ?? "");
            const alt = `${work.data.title} — image ${i + 1}`;
            return (
              <li class="grid-item">
                <a
                  href={src}
                  aria-label={`Open image ${i + 1} for ${work.data.title}`}
                >
                  <div class="image-wrapper">
                    <Picture
                      src={img}
                      alt={alt}
                      formats={["avif", "webp"]}
                      widths={[400, 800, 1200]}
                      sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
                      class="list-image"
                      loading="lazy"
                      fetchpriority="auto"
                    />
                  </div>
                </a>
              </li>
            );
          })}
        </ul>
      )
    }

    {
      work.data.footer && (
        <div
          class="text-block-content footer"
          set:html={marked.parse(work.data.footer)}
        />
      )
    }
  </article>
</BaseLayout>

<style>
  /* ------------------------------------------------------------
     Base layout & type (shared across all themes)
     Keep this lean; themes only override what's necessary.
  ------------------------------------------------------------ */
  .work-hero {
    display: grid;
    grid-template-columns: 1fr minmax(0, 1fr);
    grid-template-areas: 
      "title ."
      "left right";
    gap: 2rem;
    align-items: start;
    max-width: var(--max-content-width, 1600px);
    margin: 0 auto;
    padding: clamp(2rem, 6vw, 6rem) 2rem 0;
    color: var(--font-color-body);
  }

  .text-block-title {
    grid-area: title;
    color: var(--font-color-title);
    display: inline-block;
    position: relative;
    padding-bottom: 2px;
    font-size: 0.8rem;
    text-transform: uppercase;
    letter-spacing: 0.18em; /* ~3px at 16px */
    font-weight: 400;
    margin: 0;
  }

  .work-hero__left {
    grid-area: left;
    display: grid;
    align-content: start;
    gap: 0.9rem;
  }

  .work-hero__right {
    grid-area: right;
  }

  .meta-stack {
    display: grid;
    gap: 0.4rem;
  }

  .meta-item {
    font-weight: 300;
    font-size: 0.8rem;
    letter-spacing: 0.08em;
    color: var(--font-color-body);
    margin: 0;
  }

  .meta-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem 0.6rem;
    list-style: none;
    margin: 0.2rem 0 0;
    padding: 0;
    font-size: 0.72rem;
    letter-spacing: 0.14em;
  }
  .meta-tag {
    font-size: 0.78rem;
    text-transform: uppercase;
    letter-spacing: 0.14em;
    font-weight: 300;
    color: var(--font-color-body);
    padding: 0;
    border: 0;
  }
  .meta-tag + .meta-tag::before {
    content: "•";
    margin: 0 0.45rem 0 0.2rem;
    color: var(--font-color-body);
  }

  .text-block-content {
    color: var(--font-color-body);
    font-weight: 300;
    font-size: 0.8rem;
    line-height: 1.6;
  }
  .text-block-content :global(p) {
    line-height: 1.7;
    margin: 0;
  }
  .text-block-content :global(p + p) {
    margin-block-start: 1.6em;
  }
  .text-block-content :global(h2) {
    font-size: 0.82rem;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    font-weight: 300;
    margin-top: 2rem;
    color: var(--font-color-title);
  }
  .text-block-content :global(h3) {
    font-size: 0.78rem;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    font-weight: 300;
    margin-top: 1.5rem;
    color: var(--font-color-title);
  }
  .text-block-content :global(ul, ol, blockquote) {
    margin-block: 1rem;
  }

  @media (max-width: 900px) {
    .work-hero {
      grid-template-columns: 1fr;
      grid-template-areas: 
        "title"
        "right"
        "left";
    }
  }

  /* Image grid */
  .work-grid {
    margin: clamp(4rem, 12vw, 10rem) auto;
    padding: 0 1rem;
    display: grid;

    /* columns from config */
    grid-template-columns: repeat(var(--grid-columns, 1), minmax(0, 1fr));

    /* default (multi-column) gaps, theme-overridable via vars */
    row-gap: var(--multi-row-gap, clamp(2.5rem, 6vw, 6rem));
    column-gap: var(--multi-col-gap, 3rem);

    list-style: none;
    align-items: end;
  }

  /* When the config sets 1 column:
   reuse your page "heighting" rhythm from Config. */
  .work-grid[data-cols="1"] {
    row-gap: var(--page-vmargin, 2rem);
    column-gap: var(--page-hmargin, 2rem);
  }

  /* Reduce margin between pinned and unpinned grids */
  .work-grid.pinned + .work-grid {
    margin-top: clamp(2.5rem, 6vw, 6rem);
  }

  .grid-item a {
    display: flex;
    flex-direction: column;
    text-decoration: none;
    color: inherit;
    transition: opacity 0.2s ease;
  }
  .grid-item a:hover {
    opacity: 0.96;
  }

  .image-wrapper {
    position: relative;
    overflow: hidden;
    border-radius: 0;
  }
  .list-image {
    display: block;
    width: 100%;
    height: auto;
  }

  /* Footer section */
  .text-block-content.footer {
    margin: 0 auto 20vh;
    padding: 0 2rem;
  }

  /* Optional: narrower text measure on wide screens for readability */
  @media (min-width: 901px) {
    .work-hero__left .text-block-content {
      max-width: 68ch;
    }
    .text-block-content.footer {
      max-width: 68ch;
    }
  }

  /* Clamp intro a bit on small screens for a compact hero */
  @media (max-width: 767px) {
    .intro {
      display: -webkit-box;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
  }
</style>

<script>
  import {Pane} from 'tweakpane';

</script>