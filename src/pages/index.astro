---
// Front-matter – unchanged apart from the comment
import BaseLayout        from "@layouts/BaseLayout.astro";
import { getCollection } from "astro:content";
import { Image }         from "astro:assets";
import type { ImageMetadata } from "astro";

// 1 = vertical, 2 = horizontal, 3 = centre-clip
const tops   = await getCollection("work", ({ data }) => data.top !== undefined);
const images = import.meta.glob<{ default: ImageMetadata }>("/src/top/*.{png,jpg}", { eager: true });

const imageMetaMap: Record<string, ImageMetadata> = Object.fromEntries(
  Object.entries(images).map(([path, mod]) => [path.split("/").pop()!.split(".")[0], mod.default]),
);

const topsWithImages = tops.map((work) => {
  const meta = imageMetaMap[work.id];
  if (!meta) {
    throw new Error(`No image called "${work.id}.png|jpg" in /src/top for “${work.data.title}”.`);
  }
  return { ...work, image: meta };
});
---

<style>
  /* one full-screen panel per artwork, *without* manual bottom margin */
  .artwork-content {
    position: relative;
    width: 100%;
    height: 100vh;
    overflow: hidden;
  }

  /* ———— intrinsic image sizing, depending on the reveal mode ———— */
  /* vertical (1) & centre-clip (3) → full width               */
  .artwork-content[data-top="1"] .artwork-image,
  .artwork-content[data-top="3"] .artwork-image {
    width: 100%;
    height: auto;
  }
  /* horizontal (2) → full height                              */
  .artwork-content[data-top="2"] .artwork-image {
    height: 100vh;
    width: auto;
  }

  .artwork-image {
    display: block;
    will-change: transform, clip-path; /* keeps the animation crisp */
  }

</style>

<BaseLayout>
  {topsWithImages.map((work) => (
    <article
      class="artwork-content"
      data-top={work.data.top}
      aria-labelledby={`work-${work.id}-title`}
    >
      <Image
        src={work.image}
        alt={work.data.title}
        class="artwork-image"
        loading="lazy"
        format="webp"
      />
    </article>
  ))}
</BaseLayout>

<!-- ---------- client-side GSAP / ScrollTrigger ----------- -->
<script>
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";
  gsap.registerPlugin(ScrollTrigger);

  /**
   * Build one ScrollTrigger-powered timeline per artwork.
   * Each timeline has two *phases* so that we can:
   *   1. “reveal the first 10 %” (or the centre-clip)
   *   2. scroll to the very end of the picture
   * This way one section never overlaps the next, yet there is no
   * hard-coded 100 vh gap either – ScrollTrigger adds exactly the
   * spacing it needs.
   */
  function initArtworks() {
    gsap.utils.toArray(".artwork-content").forEach((section) => {
      const img  = section.querySelector("img");
      const mode = Number(section.dataset.top);

      if (!img.complete) img.addEventListener("load", () => makeTimeline(section, img, mode));
      else               makeTimeline(section, img, mode);
    });
  }

  function makeTimeline(section, img, mode) {
    /** Helper numbers we need more than once */
    const vOverflow = Math.max(0, img.naturalHeight - window.innerHeight);
    const hOverflow = Math.max(0, img.naturalWidth  - window.innerWidth);

    /* The timeline runs while the section is *pinned*.                    *
     * end: "+=<distance>" tells ScrollTrigger exactly how long the pin is */
    const tl = gsap.timeline({
      scrollTrigger: {
        trigger: section,
        start: mode === 3 ? "center center" : "top top",
        pin: true,
        scrub: 1,
        anticipatePin: 1,
        invalidateOnRefresh: true,
        // one extra viewport for the “10 % reveal” phase
        end: () => "+=" + (
          mode === 1 ? vOverflow + window.innerHeight :
          mode === 2 ? hOverflow + window.innerHeight :
          /* mode 3  */ window.innerHeight
        ),
      },
    });

    /* ---------- phase 1: reveal the first 10 % (or centre clip) --------- */
    if (mode === 1) {
      // show only the top 10 % → clip bottom 90 %
      tl.fromTo(
        img,
        { clipPath: "inset(0% 0% 90% 0%)" },
        { clipPath: "inset(0% 0% 0% 0%)", ease: "none", duration: 0.5 },
        0,
      );
    } else if (mode === 2) {
      // show only the left 10 % → clip right 90 %
      tl.fromTo(
        img,
        { clipPath: "inset(0% 90% 0% 0%)" },
        { clipPath: "inset(0% 0% 0% 0%)", ease: "none", duration: 0.5 },
        0,
      );
    } else {
      // centre-clip: show 20 % × 20 % in the middle of the picture
      tl.fromTo(
        img,
        { clipPath: "inset(40% 40% 40% 40%)" },
        { clipPath: "inset(0% 0% 0% 0%)", ease: "none", duration: 1 },
        0,
      );
    }

    /* ---------- phase 2: scroll through the rest of the picture --------- */
    if (mode === 1) {
      tl.to(
        img,
        { y: -vOverflow, ease: "none", duration: 0.5 },
        ">",
      );
    } else if (mode === 2) {
      tl.to(
        img,
        { x: -hOverflow, ease: "none", duration: 0.5 },
        ">",
      );
    }
    // mode 3 has no second phase – the simple clip expansion is enough
  }

  /** Run after the whole document (incl. images) is ready */
  if (document.readyState === "complete") initArtworks();
  else window.addEventListener("load", initArtworks);
</script>
