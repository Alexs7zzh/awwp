---
// Front-matter – unchanged apart from the comment
import BaseLayout from "@layouts/BaseLayout.astro";
import { getCollection } from "astro:content";
import { Image } from "astro:assets";
import type { ImageMetadata } from "astro";

// 1 = vertical, 2 = horizontal, 3 = centre-clip
const tops = await getCollection("work", ({ data }) => data.top !== undefined);
const images = import.meta.glob<{ default: ImageMetadata }>(
  "/src/top/*.{png,jpg}",
  { eager: true },
);

const imageMetaMap: Record<string, ImageMetadata> = Object.fromEntries(
  Object.entries(images).map(([path, mod]) => [
    path.split("/").pop()!.split(".")[0],
    mod.default,
  ]),
);

const topsWithImages = tops.map((work) => {
  const meta = imageMetaMap[work.id];
  if (!meta) {
    throw new Error(
      `No image called "${work.id}.png|jpg" in /src/top for “${work.data.title}”.`,
    );
  }
  return { ...work, image: meta };
});
---

<style>
  /* one full-screen panel per artwork, *without* manual bottom margin */
  .artwork-content {
    position: relative;
    width: 100%;
    height: 100vh;
    overflow: hidden;
  }

  /* ———— intrinsic image sizing, depending on the reveal mode ———— */
  /* vertical (1)                      */
  .artwork-content[data-top="1"] .artwork-image {
    width: 50%;
    height: auto;
  }
  .artwork-content[data-top="1"] {
    margin-top: 50vh;
  }
  /* horizontal (2) → full height                              */
  .artwork-content[data-top="2"] .artwork-image {
    height: 60vh;
    width: auto;
  }
  .artwork-content[data-top="2"] {
    margin-top: 50vh; /* optional – mirrors the vertical panels’ gap */
  }

  .artwork-content[data-top="3"] .artwork-image {
    height: 100vh;
    width: 100%;
    object-fit: cover;
  }

  .artwork-image {
    display: block;
    will-change: transform, clip-path;
  }
</style>

<BaseLayout>
  {
    topsWithImages.map((work) => (
      <article
        class="artwork-content"
        data-top={work.data.top}
        aria-labelledby={`work-${work.id}-title`}
      >
        <Image
          src={work.image}
          alt={work.data.title}
          class="artwork-image"
          loading="lazy"
          format="webp"
        />
      </article>
    ))
  }
</BaseLayout>

<!-- ---------- client-side GSAP / ScrollTrigger ----------- -->
<script>
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";
  gsap.registerPlugin(ScrollTrigger);

  /**
   * Build one ScrollTrigger-powered timeline per artwork.
   * Each timeline has two *phases* so that we can:
   *   1. “reveal the first 10 %” (or the centre-clip)
   *   2. scroll to the very end of the picture
   * This way one section never overlaps the next, yet there is no
   * hard-coded 100 vh gap either – ScrollTrigger adds exactly the
   * spacing it needs.
   */
  function initArtworks() {
    gsap.utils.toArray(".artwork-content").forEach((section) => {
      const img = section.querySelector("img");
      const mode = Number(section.dataset.top);

      if (!img.complete)
        img.addEventListener("load", () => makeTimeline(section, img, mode));
      else makeTimeline(section, img, mode);
    });
  }

  function makeTimeline(section, img, mode) {
    /** Helper numbers we need more than once */
    const hOverflow = Math.max(0, img.offsetWidth - window.innerWidth);

    const triggerEl = mode === 3 ? img : section;
    /* The timeline runs while the section is *pinned*.                    *
     * end: "+=<distance>" tells ScrollTrigger exactly how long the pin is */
    const tl = gsap.timeline({
      scrollTrigger: {
        trigger: triggerEl,
        start: mode === 3 ? "center center" : "top top",
        pin: section,
        scrub: mode === 3 ? 1 : true,
        anticipatePin: 1,
        invalidateOnRefresh: true,
        // one extra viewport for the “10 % reveal” phase
        end: () =>
          "+=" +
          (mode === 1
            ? img.offsetHeight
            : mode === 2
              ? hOverflow + window.innerHeight
              : /* mode 3  */ window.innerHeight),
      },
    });

    /* ---------- phase 1: reveal the first 10 % (or centre clip) --------- */
    if (mode === 1) {
      const vOverflow = Math.max(0, img.offsetHeight - innerHeight);

      /* pin lasts exactly that distance */
      tl.scrollTrigger.end = "+=" + vOverflow;

      /* one clean slide from start (y = 0) to end (picture’s bottom edge
   reaches the bottom of the viewport)                               */
      tl.fromTo(img, { y: 0 }, { y: -vOverflow, ease: "none" });
    } else if (mode === 2) {
      const vpW = window.innerWidth;
      const imgW = img.offsetWidth;
      const xStart = vpW - 0.1 * imgW;
      const xEnd = imgW <= vpW ? (vpW - imgW) / 2 : 0;
      const slideDist = xStart - xEnd;
      tl.scrollTrigger.end = "+=" + slideDist;
      ScrollTrigger.refresh();
      tl.fromTo(
        img,
        { x: xStart }, // picture starts on the right
        { x: xEnd, ease: "none" }, // ends flush with the left edge
      );
    } else {
      // centre-clip: show 20 % × 20 % in the middle of the picture
      tl.fromTo(
        img,
        { clipPath: "inset(40% 40% 40% 40%)" },
        { clipPath: "inset(0% 0% 0% 0%)", ease: "none", duration: 1 },
        0,
      );
    }
  }

  /** Run after the whole document (incl. images) is ready */
  if (document.readyState === "complete") initArtworks();
  else window.addEventListener("load", initArtworks);
</script>
