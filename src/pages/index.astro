---
import BaseLayout from "@layouts/BaseLayout.astro";
import LongImage from "@components/LongImage.astro"
import MultiImageSide from "@components/MultiImage_Side.astro"

const allImages = import.meta.glob<{ default: ImageMetadata }>(
  "/works/**/*.{png,jpg,jpeg,webp}",
  { eager: true }
);
const images: Record<string, ImageMetadata> = {};
for (const [path, mod] of Object.entries(allImages)) {
  const img = mod.default;

  const noExt = path.replace(/\.(png|jpe?g|webp)$/i, "");

  const relFromContent = noExt.split("/works").pop()!;
  const basename = relFromContent.split("/").pop()!;
  images[basename] = img;
}

console.log(images)
---

<BaseLayout>
  <LongImage id="dismantle" image={images["dismantle_top"]} />
  <MultiImageSide id="clair" images={[images["clair_01"], images["clair_02"], images["clair_back"], images["ikebukuro_thumb"]]}/>
  <LongImage id="dragonrain" image={images["dragonrain_top"]} />
  <LongImage id="triplet" image={images["triplet_top"]} />
</BaseLayout>

<script>
  function updatePositions() {
    const vh = window.innerHeight;
    const isMobile = window.matchMedia("(max-width: 767px)").matches;
    // MODIFICATION: Select all artwork containers, not just one type.
    const artworks = document.querySelectorAll(".artwork-content");

    // --- Opacity Logic ---
    // This part now works on both component types automatically because
    // the selector above was broadened.
    let dominantElement = null;
    let maxVisibleHeight = -1;
    const visibleElements = [];

    artworks.forEach((art) => {
      const rect = art.getBoundingClientRect();
      if (rect.bottom > 0 && rect.top < vh) {
        const visibleTop = Math.max(0, rect.top);
        const visibleBottom = Math.min(vh, rect.bottom);
        const visibleHeight = visibleBottom - visibleTop;

        if (visibleHeight > 0) {
          visibleElements.push(art);
          if (visibleHeight > maxVisibleHeight) {
            maxVisibleHeight = visibleHeight;
            dominantElement = art;
          }
        }
      }
    });

    const areMultipleVisible = visibleElements.length > 1;
    artworks.forEach((art) => {
      art.style.transition = "opacity 0.3s ease";
      const isVisible = visibleElements.includes(art);
      const isDominant = art === dominantElement;

      if (areMultipleVisible && isVisible && !isDominant) {
        art.style.opacity = "0.7";
      } else {
        art.style.opacity = "1";
      }
    });
    // --- End Opacity Logic ---

    // --- Modified Sticky Positioning Logic ---
    artworks.forEach((art) => {
      const text = art.querySelector(".artwork-link");
      if (text) {
        text.style.position = "";
        text.style.top = "";
        text.style.right = "";
        text.style.width = "";
        text.style.margin = "";
        text.style.zIndex = "";
      }
    });

    if (isMobile) return;

    const rootFontSize = parseFloat(
      getComputedStyle(document.documentElement).fontSize,
    );
    const pinnedTopPx = 2 * rootFontSize;
    const pinnedRightPx = 2 * rootFontSize;

    artworks.forEach((art) => {
      // MODIFICATION: Find the correct element to measure for height.
      // For LongImage, it's the single image.
      // For MultiImageSide, it's the container of all images.
      let scrollableElement;
      if (art.classList.contains('long-image')) {
        scrollableElement = art.querySelector(".artwork-image");
      } else if (art.classList.contains('multi-image')) {
        scrollableElement = art.querySelector(".images-container");
      }

      const text = art.querySelector(".artwork-link");
      if (!scrollableElement || !text) return; // Use the new variable

      const rect = scrollableElement.getBoundingClientRect(); // Measure the correct element

      if (rect.height <= vh) return;

      const naturalWidth = text.offsetWidth;

      let mode = "normal";
      if (rect.top <= 0 && rect.bottom > vh) {
        mode = "pinned";
      } else if (rect.top <= 0 && rect.bottom <= vh && rect.bottom > 0) {
        mode = "leaving";
      }

      if (mode !== "normal") {
        text.style.position = "fixed";
        text.style.right = `${pinnedRightPx}px`;
        text.style.width = `${naturalWidth}px`;
        text.style.margin = "0";
        text.style.zIndex = "10";

        if (mode === "pinned") {
          text.style.top = `${pinnedTopPx}px`;
        } else if (mode === "leaving") {
          const moved = vh - rect.bottom;
          const newTopPx = pinnedTopPx - moved;
          text.style.top = `${newTopPx}px`;
        }
      }
    });
  }

  let ticking = false;
  window.addEventListener("scroll", () => {
    if (!ticking) {
      requestAnimationFrame(() => {
        updatePositions();
        ticking = false;
      });
      ticking = true;
    }
  });

  window.addEventListener("resize", updatePositions);

  // MODIFICATION: Handle image loads for all images in all components.
  const artworksWithImages = document.querySelectorAll(".artwork-content");
  artworksWithImages.forEach((art) => {
    const imgs = art.querySelectorAll(".artwork-image"); // Get ALL images
    imgs.forEach(img => {
      if (img) {
        img.addEventListener("load", updatePositions);
      }
    });
  });

  // Initial update
  updatePositions();
</script>
