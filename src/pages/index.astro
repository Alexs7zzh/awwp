---
import BaseLayout from "@layouts/BaseLayout.astro";
import LongImage from "@components/LongImage.astro";
import MultiImage from "@components/MultiImage.astro";
import { imageStore } from "@lib/imageStore";

const img = (id: string) => imageStore.requireImage(id);
---

<BaseLayout>
  <LongImage
    id="dismantle"
    image={img("dismantle:dismantle_top")}
    mobile={img("dismantle:dismantle_thumb")}
  />
  <MultiImage
    id="clair"
    images={[
      img("clair:clair_01"),
      img("clair:clair_02"),
      img("clair:ikebukuro_thumb"),
      img("clair:clair_back"),
    ]}
    positions={[0.5, 1, 0.1]}
  />
  <LongImage id="dragonrain" image={img("dragonrain:dragonrain_top")} />
  <LongImage id="triplet" image={img("triplet:triplet_top")} />
</BaseLayout>

<script>
(() => {
  const arts = Array.from(document.querySelectorAll('.artwork-content'));
  if (!arts.length) return;

  const index = new Map(arts.map((el, i) => [el, i]));
  // store only data derived from IO entries
  const state = new Map(arts.map((el) => [el, { coverage: 0, visible: false, center: Infinity }]));
  let active = null;

  const EPS = 0.04; // hysteresis
  // you don’t need many thresholds; ~10 is a good balance
  const thresholds = [0, 0.1, 0.25, 0.5, 0.75, 0.9, 0.98, 1];

  function pickWinner() {
    const vh = window.innerHeight || 1;
    const mid = vh / 2;

    let best = null, bestCov = 0, bestDist = Infinity;

    for (const el of arts) {
      const s = state.get(el);
      if (!s.visible || s.coverage <= 0) continue;

      const dist = Math.abs(s.center - mid);
      if (
        s.coverage > bestCov + 1e-6 ||
        (Math.abs(s.coverage - bestCov) <= 1e-6 && dist < bestDist - 1) ||
        (Math.abs(s.coverage - bestCov) <= 1e-6 && Math.abs(dist - bestDist) <= 1 && index.get(el) < index.get(best))
      ) {
        best = el; bestCov = s.coverage; bestDist = dist;
      }
    }

    if (!best) return;
    if (active && best !== active) {
      const currCov = state.get(active).coverage;
      if (bestCov < currCov + EPS) return; // hysteresis: avoid flip-flop
    }

    if (best !== active) {
      arts.forEach(a => a.classList.toggle('is-muted', a !== best));
      active = best;
    }
  }

  const io = new IntersectionObserver((entries) => {
    const vh = (entries[0]?.rootBounds?.height) || window.innerHeight || 1;

    for (const e of entries) {
      // viewport coverage (not element ratio)
      const coverage = Math.max(0, Math.min(1, e.intersectionRect.height / vh));
      // center from IO’s snapshot (no layout read)
      const center = (e.boundingClientRect.top + e.boundingClientRect.bottom) / 2;

      state.set(e.target, { coverage, visible: e.isIntersecting, center });
    }

    pickWinner();
  }, { threshold: thresholds });

  arts.forEach(el => io.observe(el));
  // on resize, just re-run selection; IO will soon provide fresh entries anyway
  window.addEventListener('resize', pickWinner, { passive: true });
  pickWinner();
})();
</script>