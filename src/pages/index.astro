---
import BaseLayout from "@layouts/BaseLayout.astro";
import { getCollection } from "astro:content";
import { Image } from "astro:assets";
import type { ImageMetadata } from "astro";

// Layout is vertical
const tops = await getCollection("work", ({ data }) => data.top !== undefined);
const images = import.meta.glob<{ default: ImageMetadata }>(
  "/src/top/*.{png,jpg}",
  { eager: true },
);

const imageMetaMap: Record<string, ImageMetadata> = Object.fromEntries(
  Object.entries(images).map(([path, mod]) => [
    path.split("/").pop()!.split(".")[0],
    mod.default,
  ]),
);

const topsWithImages = tops.map((work) => {
  const meta = imageMetaMap[work.id];
  if (!meta) {
    throw new Error(
      `No image called \"${work.id}.png|jpg\" in /src/top for “${work.data.title}”.`,
    );
  }
  return { ...work, image: meta };
});
---

<BaseLayout>
  {
    topsWithImages.map((work) => (
      <article
        class="artwork-content"
        aria-labelledby={`work-${work.id}-title`}
      >
        <Image
          src={work.image}
          alt={work.data.title}
          class="artwork-image"
          loading="lazy"
          format="webp"
        />
        <a href={`/works/${work.id}/`} class="artwork-link">
          <h2 id={`work-${work.id}-title`} class="title">
            {work.data.title}
          </h2>
          <p class="description">{work.data.intro}</p>
        </a>
      </article>
    ))
  }
</BaseLayout>

<style>
  .artwork-content {
    display: flex;
    align-items: flex-start;
    gap: 2rem;
    width: 100%;
    margin-bottom: 50vh;
  }

  /* On smaller screens, stack the layout */
  @media (max-width: 767px) {
    .artwork-content {
      flex-direction: column;
      gap: 1rem;
      margin-bottom: 25vh;
    }
    .artwork-image {
      width: 100% !important; /* Override inline style */
    }
    .artwork-link {
        margin-top: 0;
        margin-right: 0;
    }
  }

  .artwork-image {
    width: 70%;
    flex-shrink: 0;
    height: auto;
    display: block;
    will-change: transform;
  }

  .artwork-link {
    text-decoration: none;
    color: inherit;
    margin-top: 2rem;
    margin-right: 2rem;
    padding: 0;
    will-change: transform;
    flex-grow: 1;
  }

  .title {
    font-size: 1rem;
    font-weight: 500;
    letter-spacing: 2px;
    margin-bottom: 0.3rem;
    display: inline-block;
    position: relative;
    padding-bottom: 2px;
  }
  .title::after {
    content: "";
    position: absolute;
    left: 0;
    bottom: 0;
    width: 0;
    height: 1px;
    background: currentColor;
    transition: width 0.3s;
  }
  .artwork-link:hover .title::after {
    width: 100%;
  }

  .description {
    line-height: 1.7;
    font-size: 0.85rem;
    color: #333;
    margin-top: 0.25rem;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 5;
    overflow: hidden;
  }
</style>

<script>
import { gsap } from "gsap";
import { ScrollTrigger } from "gsap/ScrollTrigger";
gsap.registerPlugin(ScrollTrigger);

// wait until every .artwork-image knows its real size
function whenImagesReady(sel, cb) {
  Promise.all(
    gsap.utils.toArray(sel).map(img =>
      img.complete ? 1 : new Promise(res => (img.onload = res))
    )
  ).then(cb);
}

whenImagesReady(".artwork-image", () => {
  const mm = gsap.matchMedia();

  mm.add("(min-width:768px)", () => {
    const cleanups = [];

    gsap.utils.toArray(".artwork-content").forEach(section => {
      const img  = section.querySelector(".artwork-image");
      if (!img || img.naturalHeight <= innerHeight) return; // skip small ones

      const travel = () => img.naturalHeight - innerHeight; // pixels to move

      // pin **only the image** so the link block keeps scrolling
      const st = ScrollTrigger.create({
        trigger: section,
        start: "top top",
        end: () => `+=${travel()}`,
        pin: img,
        pinSpacing: "margin",     // prevent flex/layout jumps
        scrub: true,
        anticipatePin: 1,
        invalidateOnRefresh: true
      });

      gsap.to(img, {               // vertical reveal
        y: () => -travel(),
        ease: "none",
        scrollTrigger: st
      });

      cleanups.push(() => st.kill());
    });

    // return a cleanup so gsap.matchMedia() removes everything on breakpoint change
    return () => cleanups.forEach(f => f());
  });

  ScrollTrigger.refresh(); // just in case
});

</script>
