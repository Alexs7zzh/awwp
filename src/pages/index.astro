---
import BaseLayout from "@layouts/BaseLayout.astro";
import LongImage from "@components/LongImage.astro"
import MultiImageSide from "@components/MultiImage_Side.astro";
import MultiImageMixed from "@components/MultiImage_Mixed.astro";
import TextMain from "@components/TextMain.astro";

const allImages = import.meta.glob<{ default: ImageMetadata }>(
  "/works/**/*.{png,jpg,jpeg,webp}",
  { eager: true }
);
const images: Record<string, ImageMetadata> = {};
for (const [path, mod] of Object.entries(allImages)) {
  const img = mod.default;

  const noExt = path.replace(/\.(png|jpe?g|webp)$/i, "");

  const relFromContent = noExt.split("/works").pop()!;
  const basename = relFromContent.split("/").pop()!;
  images[basename] = img;
}
---
 
<BaseLayout>
  <LongImage id="dismantle" image={images["dismantle_top"]} />
  <MultiImageSide id="clair"
    images={[images["clair_01"], images["clair_02"], images["ikebukuro_thumb"], images["clair_back"] ]}
    positions={[0.5, 1, 0.1]}
    />
  <LongImage id="dragonrain" image={images["dragonrain_top"]} />
  <MultiImageMixed id="clair" images={[images["clair_01"], images["clair_02"], images["clair_back"], images["ikebukuro_thumb"]]}/>
  <TextMain image={images["arsdas_thumb"]} title="Mother Fluctuation" content="本作は気候変動のビッグデータを用いた没入型のオーディオビジュアルインスタレーションです。複数のシーンを通して、温度、海面高度、市場、文明などのフラクチュエーション（上昇と下降）という現象に着目し、人間の営為には頓着することのない母なる地球が描かれています。日本伝統の地獄絵の表現を参照しながら、オープンな科学データにアート特有の操作を適用し、温暖化が人類にもたらす大災害を想起させる風景を可視化／可聴化しています。8K映像と5.1ch立体音響を駆使して、没入的な映像音響空間を構築しました。" />
  <LongImage id="triplet" image={images["triplet_top"]} />
</BaseLayout>

<script>
  /* -----------------------------------------------------------
   *  Helpers – read the spacing that was set via CSS variables
   * --------------------------------------------------------- */
  const PX_FALLBACK = 32;          // ≒ 2 rem – used if nothing is defined

  /** Convert something like “2rem”, “24px”, “1.5em” → absolute px */
  function toPx(lengthStr, contextPx) {
    const v = parseFloat(lengthStr);
    if (lengthStr.endsWith("rem") || lengthStr.endsWith("em"))
      return v * contextPx;
    return v;                      // px values arrive as “…px”
  }

  /** Get vertical / horizontal spacing for one `.artwork-link` */
  function getMargins(el) {
    const rootStyle  = getComputedStyle(document.documentElement);
    const linkStyle  = getComputedStyle(el);

    const rootFontPx = parseFloat(rootStyle.fontSize) || 16;

    // 1. per-element margin (takes priority)
    let v = parseFloat(linkStyle.marginTop);
    let h = parseFloat(linkStyle.marginRight);

    // 2. fall back to CSS custom properties (defined on <BaseLayout/>)
    if (!v) v = toPx(rootStyle.getPropertyValue("--text-vertical-margin")   || "", rootFontPx) || PX_FALLBACK;
    if (!h) h = toPx(rootStyle.getPropertyValue("--text-horizontal-margin") || "", rootFontPx) || PX_FALLBACK;

    return { v, h };
  }

  /* -----------------------------------------------------------
   *  Main routine – unchanged except where noted
   * --------------------------------------------------------- */
  function updatePositions() {
    const vh       = window.innerHeight;
    const isMobile = window.matchMedia("(max-width: 767px)").matches;
    const artworks = document.querySelectorAll(".artwork-content");

    /* ---------- 1. opacity section (unchanged) ---------- */
    let dominantElement = null;
    let maxVisibleHeight = -1;
    const visibleElements = [];

    artworks.forEach((art) => {
      const rect = art.getBoundingClientRect();
      if (rect.bottom > 0 && rect.top < vh) {
        const visibleTop     = Math.max(0, rect.top);
        const visibleBottom  = Math.min(vh, rect.bottom);
        const visibleHeight  = visibleBottom - visibleTop;

        if (visibleHeight > 0) {
          visibleElements.push(art);
          if (visibleHeight > maxVisibleHeight) {
            maxVisibleHeight = visibleHeight;
            dominantElement  = art;
          }
        }
      }
    });

    const areMultipleVisible = visibleElements.length > 1;
    artworks.forEach((art) => {
      art.style.transition = "opacity 0.3s ease";
      const isVisible  = visibleElements.includes(art);
      const isDominant = art === dominantElement;

      art.style.opacity = (areMultipleVisible && isVisible && !isDominant) ? "0.3" : "1";
    });

    artworks.forEach((art) => {
      const text = art.querySelector(".artwork-link");
      if (!text) return;

      text.style.position = "";
      text.style.top      = "";
      text.style.right    = "";
      text.style.width    = "";
      text.style.margin   = "";
      text.style.zIndex   = "";
      text.style.transform = "";
    });

    if (isMobile) return;  // no pinning on mobile

    artworks.forEach((art) => {
      const text = art.querySelector(".artwork-link");
      if (!text) return;

      /* what part of this artwork should drive the scroll logic? */
      let scrollableElement;
      if (art.classList.contains("long-image")) {
        scrollableElement = art.querySelector(".artwork-image");
      } else if (art.classList.contains("multi-image")) {
        scrollableElement = art.querySelector(".images-container");
      }

      if (!scrollableElement) return;

      const rect = scrollableElement.getBoundingClientRect();
      if (rect.height <= vh) return;  // no need to pin if it fits

      const { v: marginV, h: marginH } = getMargins(text);

      const naturalWidth = text.offsetWidth;

      let mode = "normal";
      if (rect.top <= 0 && rect.bottom > vh)                mode = "pinned";
      else if (rect.top <= 0 && rect.bottom <= vh && rect.bottom > 0) mode = "leaving";

      if (mode !== "normal") {
        text.style.position = "fixed";
        text.style.right    = `${marginH}px`; 
        text.style.width    = `${naturalWidth}px`;
        text.style.margin   = 0;
        text.style.zIndex   = 10;
        if (mode === "pinned") {
          text.style.top = `${marginV}px`;
        } else if (mode === "leaving") {
          const moved     = vh - rect.bottom;
          const newTopPx  = marginV - moved;
          text.style.top  = `${newTopPx}px`;
        }
      }

      art.dataset.pinned = mode === "normal" ? "false" : "true";
    });
  }

  /* ---------- 3. event wiring (unchanged) ---------- */
  let ticking = false;
  window.addEventListener("scroll", () => {
    if (!ticking) {
      requestAnimationFrame(() => {
        updatePositions();
        ticking = false;
      });
      ticking = true;
    }
  });
  window.addEventListener('resize', updatePositions);

  // run once images are loaded
  document.querySelectorAll(".artwork-content").forEach((art) => {
    art.querySelectorAll(".artwork-image").forEach((img) => {
      img.addEventListener("load", updatePositions);
    });
  });

  updatePositions();
</script>
