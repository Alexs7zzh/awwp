---
import BaseLayout from "@layouts/BaseLayout.astro";
import { getCollection } from "astro:content";
import { Image } from "astro:assets";
import type { ImageMetadata } from "astro";

// Layout is vertical
const tops = await getCollection("work", ({ data }) => data.top !== undefined);
const images = import.meta.glob<{ default: ImageMetadata }>(
  "/src/top/*.{png,jpg}",
  { eager: true },
);

const imageMetaMap: Record<string, ImageMetadata> = Object.fromEntries(
  Object.entries(images).map(([path, mod]) => [
    path.split("/").pop()!.split(".")[0],
    mod.default,
  ]),
);

const topsWithImages = tops.map((work) => {
  const meta = imageMetaMap[work.id];
  if (!meta) {
    throw new Error(
      `No image called \"${work.id}.png|jpg\" in /src/top for “${work.data.title}”.`,
    );
  }
  return { ...work, image: meta };
});
---

<BaseLayout>
  {
    topsWithImages.map((work) => (
      <article
        class="artwork-content"
        aria-labelledby={`work-${work.id}-title}`}
      >
        <Image
          src={work.image}
          alt={work.data.title}
          class="artwork-image"
          loading="lazy"
          format="webp"
        />
        <a href={`/works/${work.id}/`} class="artwork-link">
          <h2 id={`work-${work.id}-title`} class="title">
            {work.data.title}
          </h2>
          <p class="description">{work.data.intro}</p>
        </a>
      </article>
    ))
  }
</BaseLayout>

<style>
  .artwork-content {
    display: flex;
    align-items: flex-start;
    gap: 2rem;
    width: 100%;
    margin-bottom: 50vh;
  }

  .artwork-image {
    width: 70%;
    flex-shrink: 0;
    height: auto;
    display: block;
  }

  .artwork-link {
    text-decoration: none;
    color: inherit;
    margin: 2rem;
    padding: 0;
    flex-grow: 1;
  }

  .title {
    font-size: 1rem;
    font-weight: 500;
    letter-spacing: 2px;
    margin-bottom: 0.3rem;
    display: inline-block;
    position: relative;
    padding-bottom: 2px;
  }
  .title::after {
    content: "";
    position: absolute;
    left: 0;
    bottom: 0;
    width: 0;
    height: 1px;
    background: currentColor;
    transition: width 0.3s;
  }
  .artwork-link:hover .title::after {
    width: 100%;
  }

  .description {
    line-height: 1.7;
    font-size: 0.85rem;
    color: #333;
    margin-top: 0.25rem;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    
    overflow: hidden;
  }

  @media (max-width: 767px) {
    .artwork-content {
      flex-direction: column;
      gap: 1rem;
      margin-bottom: 25vh;
    }
    .artwork-image {
      width: 100% !important; /* Override inline style */
    }
    .artwork-link {
        margin-top: 0;
    }
    .description {
      -webkit-line-clamp: 6;
    }
  }
</style>

<script>
  function updatePositions() {
    const vh = window.innerHeight;
    const isMobile = window.matchMedia('(max-width: 767px)').matches;
    const artworks = document.querySelectorAll('.artwork-content');

    // First, reset all to normal to allow measuring natural state
    artworks.forEach((art) => {
      const text = art.querySelector<HTMLElement>('.artwork-link');
      if (text) {
        text.style.position = '';
        text.style.top = '';
        text.style.right = '';
        text.style.width = '';
        text.style.margin = '';
        text.style.zIndex = '';
      }
    });

    if (isMobile) return;

    // Get rem size for calculations
    const rootFontSize = parseFloat(getComputedStyle(document.documentElement).fontSize);
    const pinnedTopPx = 2 * rootFontSize;
    const pinnedRightPx = 2 * rootFontSize;

    artworks.forEach((art) => {
      const image = art.querySelector<HTMLElement>('.artwork-image');
      const text = art.querySelector<HTMLElement>('.artwork-link');
      if (!image || !text) return;
      const rect = image.getBoundingClientRect();

      // Skip if not tall enough
      if (rect.height <= vh) return;

      // Measure natural width after reset
      const naturalWidth = text.offsetWidth;

      let mode = 'normal';
      if (rect.top <= 0 && rect.bottom > vh) {
        mode = 'pinned';
      } else if (rect.top <= 0 && rect.bottom <= vh && rect.bottom > 0) {
        mode = 'leaving';
      }

      if (mode !== 'normal') {
        text.style.position = 'fixed';
        text.style.right = `${pinnedRightPx}px`;
        text.style.width = `${naturalWidth}px`;
        text.style.margin = '0';
        text.style.zIndex = '10';

        if (mode === 'pinned') {
          text.style.top = `${pinnedTopPx}px`;
        } else if (mode === 'leaving') {
          const moved = vh - rect.bottom;
          const newTopPx = pinnedTopPx - moved;
          text.style.top = `${newTopPx}px`;
        }
      }
    });
  }

  // Throttle scroll updates with RAF
  let ticking = false;
  window.addEventListener('scroll', () => {
    if (!ticking) {
      requestAnimationFrame(() => {
        updatePositions();
        ticking = false;
      });
      ticking = true;
    }
  });

  // Handle resize
  window.addEventListener('resize', updatePositions);

  // Handle image loads (for lazy loading)
  const artworks = document.querySelectorAll('.artwork-content');
  artworks.forEach((art) => {
    const img = art.querySelector('.artwork-image');
    if (img) img.addEventListener('load', updatePositions);
  });

  // Initial update
  updatePositions();
</script>
