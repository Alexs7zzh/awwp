---
import BaseLayout from "@layouts/BaseLayout.astro";
import { getCollection } from "astro:content";
import { Image } from "astro:assets";
import type { ImageMetadata } from "astro";

// Layout is vertical
const tops = await getCollection("work", ({ data }) => data.top !== undefined);
const images = import.meta.glob<{ default: ImageMetadata }>(
  "/src/top/*.{png,jpg}",
  { eager: true },
);

const imageMetaMap: Record<string, ImageMetadata> = Object.fromEntries(
  Object.entries(images).map(([path, mod]) => [
    path.split("/").pop()!.split(".")[0],
    mod.default,
  ]),
);

const topsWithImages = tops.map((work) => {
  const meta = imageMetaMap[work.id];
  if (!meta) {
    throw new Error(
      `No image called \"${work.id}.png|jpg\" in /src/top for “${work.data.title}”.`,
    );
  }
  return { ...work, image: meta };
});
---

<BaseLayout>
  {
    topsWithImages.map((work) => (
      <article
        class="artwork-content"
        aria-labelledby={`work-${work.id}-title`}
      >
        <Image
          src={work.image}
          alt={work.data.title}
          class="artwork-image"
          loading="lazy"
          format="webp"
        />
        <a href={`/works/${work.id}/`} class="artwork-link">
          <h2 id={`work-${work.id}-title`} class="title">
            {work.data.title}
          </h2>
          <p class="description">{work.data.intro}</p>
        </a>
      </article>
    ))
  }
</BaseLayout>

<style>
  .artwork-content {
    display: flex;
    align-items: flex-start;
    gap: 2rem;
    width: 100%;
    margin-bottom: 50vh;
  }

  /* On smaller screens, stack the layout */
  @media (max-width: 767px) {
    .artwork-content {
      flex-direction: column;
      gap: 1rem;
      margin-bottom: 25vh;
    }
    .artwork-image {
      width: 100% !important; /* Override inline style */
    }
    .artwork-link {
        margin-top: 0;
        margin-right: 0;
    }
  }

  .artwork-image {
    width: 70%;
    flex-shrink: 0;
    height: auto;
    display: block;
    will-change: transform;
  }

  .artwork-link {
    text-decoration: none;
    color: inherit;
    margin-top: 2rem;
    margin-right: 2rem;
    padding: 0;
    will-change: transform;
    flex-grow: 1;
  }

  .title {
    font-size: 1rem;
    font-weight: 500;
    letter-spacing: 2px;
    margin-bottom: 0.3rem;
    display: inline-block;
    position: relative;
    padding-bottom: 2px;
  }
  .title::after {
    content: "";
    position: absolute;
    left: 0;
    bottom: 0;
    width: 0;
    height: 1px;
    background: currentColor;
    transition: width 0.3s;
  }
  .artwork-link:hover .title::after {
    width: 100%;
  }

  .description {
    line-height: 1.7;
    font-size: 0.85rem;
    color: #333;
    margin-top: 0.25rem;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 5;
    overflow: hidden;
  }
</style>

<script>
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";
  gsap.registerPlugin(ScrollTrigger);

  function initArtworks() {
    // Use the modern gsap.matchMedia() for responsive animations
    const mm = gsap.matchMedia();

    mm.add("(min-width: 768px)", () => {
      // This function runs when the media query matches
      const triggers = [];

      // A small delay to ensure all images are rendered and have dimensions
      setTimeout(() => {
        gsap.utils.toArray(".artwork-content").forEach((section) => {
          const img = section.querySelector("img.artwork-image");
          if (img) {
            // Pass the triggers array to the setup function
            const st = setupAnimation(section, img);
            if (st) triggers.push(st);
          }
        });
      }, 100);

      // Return a cleanup function that will be called when the media query no longer matches
      return () => {
        triggers.forEach((st) => st.kill());
      };
    });
  }

  function setupAnimation(section, img) {
    // Only apply the effect if the image is taller than the viewport
    if (img.offsetHeight <= window.innerHeight) {
      return null;
    }

    // This timeline will animate the image upwards while the parent container is pinned.
    const tl = gsap.timeline({
      scrollTrigger: {
        trigger: section,
        start: "top top",
        end: "bottom bottom",
        scrub: true,
        pin: true, // Pin the entire section
        pinSpacing: true,
        invalidateOnRefresh: true,
      },
    });

    // Animate the image's "y" position.
    // The distance to move is the image's total height minus the viewport's height.
    // This makes the image scroll perfectly from top to bottom within the viewport.
    tl.to(img, {
      y: -(img.offsetHeight - window.innerHeight),
      ease: "none", // Use a linear ease for a direct scroll correlation
    });

    // Return the ScrollTrigger instance so it can be killed on cleanup
    return tl.scrollTrigger;
  }

  document.addEventListener("DOMContentLoaded", initArtworks);
</script>
