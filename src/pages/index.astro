---
import BaseLayout from "@layouts/BaseLayout.astro";
import { getCollection } from "astro:content";
import { Image } from "astro:assets";
import type { ImageMetadata } from "astro";

// Layout is vertical
const tops = await getCollection("work", ({ data }) => data.top !== undefined);
const images = import.meta.glob<{ default: ImageMetadata }>(
  "/src/top/*.{png,jpg}",
  { eager: true },
);

const imageMetaMap: Record<string, ImageMetadata> = Object.fromEntries(
  Object.entries(images).map(([path, mod]) => [
    path.split("/").pop()!.split(".")[0],
    mod.default,
  ]),
);

const topsWithImages = tops.map((work) => {
  const meta = imageMetaMap[work.id];
  if (!meta) {
    throw new Error(
      `No image called \"${work.id}.png|jpg\" in /src/top for “${work.data.title}”.`,
    );
  }
  return { ...work, image: meta };
});
---
<BaseLayout>
  {
    topsWithImages.map((work) => (
      <article
        class="artwork-content"
        aria-labelledby={`work-${work.id}-title`}
      >
        <Image
          src={work.image}
          alt={work.data.title}
          class="artwork-image"
          loading="lazy"
          format="webp"
        />
        <a href={`/works/${work.id}/`} class="artwork-link overlay-vertical">
          <h2 id={`work-${work.id}-title`} class="title">
            {work.data.title}
          </h2>
          <p class="description">{work.data.intro}</p>
        </a>
      </article>
    ))
  }
</BaseLayout>

<style>
  /* ───────────────── Base section ───────────────── */
  .artwork-content {
    position: relative;
    width: 100%;
    /* --- FINAL FIX for SPACING --- */
    /* All margins are removed. Sections will be flush against each other. */
    margin: 0;
    /* The container must contain its absolutely positioned children for height calculation */
    height: max-content;
  }

  /* image sizing */
  .artwork-content .artwork-image {
    width: 70%;
    height: auto;
    /* Image position is no longer needed as it's controlled by GSAP */
  }

  .artwork-image {
    display: block;
    will-change: transform;
  }

  /* ───────────────── Overlay blocks ───────────────── */
  .artwork-link {
    text-decoration: none;
    color: inherit;
  }

  .overlay-vertical {
    /* Position is absolute so it can be moved independently of the image */
    position: absolute; 
    padding: 0.75rem 1.25rem;
    background: rgba(255 255 255 / 0.85);
    backdrop-filter: blur(6px);
    border-radius: 6px;
    max-width: 60ch;
    z-index: 10;
    top: 2rem;
    right: 2rem;
    will-change: transform;
  }
  
  /* Title and description styles remain the same */
  .title {
    font-size: 1rem;
    font-weight: 500;
    letter-spacing: 2px;
    margin-bottom: 0.3rem;
    display: inline-block;
    position: relative;
    padding-bottom: 2px;
  }
  .title::after {
    content: "";
    position: absolute;
    left: 0;
    bottom: 0;
    width: 0;
    height: 1px;
    background: currentColor;
    transition: width 0.3s;
  }
  .artwork-link:hover .title::after {
    width: 100%;
  }

  .description {
    line-height: 1.7;
    font-size: 0.85rem;
    color: #333;
    margin-top: 0.25rem;
    display: -webkit-box;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: 5;
    overflow: hidden;
  }
</style>

<script>
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";
  gsap.registerPlugin(ScrollTrigger);

  function initArtworks() {
    // A small delay to ensure all images are rendered and have dimensions
    setTimeout(() => {
      gsap.utils.toArray(".artwork-content").forEach((section) => {
        const img = section.querySelector("img.artwork-image");
        setupAnimation(section, img);
      });
    }, 100);
  }

  function setupAnimation(section, img) {
    const text = section.querySelector(".overlay-vertical");
    
    // Only run the animation if the image is taller than the viewport
    if (img.offsetHeight <= window.innerHeight) {
      return; 
    }

    const tl = gsap.timeline({
      scrollTrigger: {
        trigger: section,
        // --- FINAL FIX ---
        // NO MORE PINNING. We just scrub the animation as the section
        // scrolls through the viewport.
        scrub: true,
        // Start when the top of the section hits the top of the viewport
        start: "top top",
        // End when the bottom of the section hits the bottom of the viewport
        // This creates a natural animation duration without any artificial space.
        end: "bottom bottom",
        invalidateOnRefresh: true,
      },
    });

    // Animate the image to move it up.
    // It moves from y=0 to a negative value that ensures its bottom
    // aligns with the viewport bottom at the end of the scroll.
    tl.to(img, {
      y: -(img.offsetHeight - window.innerHeight),
      ease: "none",
    });

    // Animate the text box to COUNTER the scroll, making it appear fixed.
    // It moves from y=0 to a positive value that is equal to the
    // total distance the section has scrolled past the top of the screen.
    // We add the animation to the timeline at position 0 to make it
    // run in parallel with the image animation.
    tl.to(text, {
        y: section.offsetHeight - window.innerHeight,
        ease: "none",
      },
      0 // Start at the same time as the image tween
    );
  }

  // Use window.onload to ensure image dimensions are available
  window.onload = initArtworks;
</script>
