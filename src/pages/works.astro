---
import BaseLayout from "@layouts/BaseLayout.astro";
import { Picture } from "astro:assets";
import { getCollection } from "astro:content";
import { imageStore } from "@lib/imageStore";

const sortedWorks = await getCollection("work").then((entries) =>
  entries.sort((a, b) => b.data.year - a.data.year),
);

const worksWithImages = sortedWorks.map((work) => ({
  workId: work.id,
  year: work.data.year,
  images: imageStore.requireImagesForWork(work.id),
}));
---

<BaseLayout>
  <ul
    class="work-grid"
    data-min-cols="2"
    data-max-cols="5"
    data-min-item-width="260"
    data-gap-col="16"
    data-gap-row="80"
    data-outer-gutter="24"
  >
    {
      worksWithImages.map((work) =>
        work.images.map((img) => (
          <li class="grid-item">
            <a
              href={`/works/${work.workId}`}
              aria-labelledby={`work-title-${work.workId}`}
            >
              <div class="image-wrapper">
                <Picture
                  src={img}
                  alt={work.workId}
                  formats={["avif", "webp"]}
                  widths={[400, 800]}
                  sizes="(max-width: 767px) 50vw, (max-width: 1199px) 33vw, 25vw"
                  class="list-image"
                  loading="lazy"
                  fetchpriority="auto"
                />
              </div>
            </a>
          </li>
        )),
      )
    }
  </ul>
</BaseLayout>

<style>
  /* Base type the same as yours */
  h1 {
    padding: 0;
    margin: 0;
    font-weight: normal;
    font-size: 1.5rem;
  }

  .work-grid {
    /* configurable via JS / data-attrs */
    --grid-cols: 2;
    --gap-col: 16px;
    --gap-row: 8rem;
    --outer-gutter: 16px;

    inline-size: 100%;
    margin-block: 10rem; /* keep your vertical rhythm */
    margin-inline: 0; /* never create extra outer margins */
    padding-inline: var(--outer-gutter);

    display: grid;
    grid-template-columns: repeat(var(--grid-cols), minmax(0, 1fr));
    gap: var(--gap-row) var(--gap-col);
    list-style: none;
    align-items: end;
    padding: 0 var(--page-padding);
  }

  .grid-item a {
    display: flex;
    flex-direction: column;
    text-decoration: none;
    color: inherit;
    transition: opacity 0.2s ease;
  }
  .grid-item a:hover {
    opacity: 0.8;
  }
  .image-wrapper {
    flex-grow: 1;
    display: flex;
    align-items: flex-end;
    margin-bottom: 0.75rem;
  }
  .list-image {
    display: block;
    width: 100%;
    height: auto;
  }
  .text-content {
    flex-shrink: 0;
  }
  .text-content h3 {
    font-size: 1rem;
    font-weight: 400;
    margin: 0 0 0.5rem 0;
    color: var(--font-color-title);
    letter-spacing: 0.2px;
  }
  .text-content .meta {
    font-size: 0.85rem;
    color: var(--font-color-body);
    margin: 0;
  }

  /* Optional: a basic no-JS fallback so it doesnâ€™t look broken if JS is off */
  @media (min-width: 768px) {
    .work-grid {
      --grid-cols: 3;
    }
  }
  @media (min-width: 1200px) {
    .work-grid {
      --grid-cols: 5;
    }
  }

  @media (min-width: 767px) {
    .text-content h3 {
      font-weight: 500;
      letter-spacing: 0.4px;
    }
  }
</style>

<script>
  interface GridConfig {
    minCols: number;
    maxCols: number;
    minItemWidth: number;
    gapCol: number;
    gapRow: number;
    fullBleed: boolean;
    outerGutter: number;
    updateSizesAttr: boolean;
  }

  function initGridSizer(
    selector: string = ".work-grid",
    baseConfig: Partial<GridConfig> = {},
  ) {
    const els = Array.from(
      document.querySelectorAll(selector),
    ) as HTMLElement[];
    if (!("ResizeObserver" in window)) return;

    els.forEach((grid) => {
      const cfg: GridConfig = {
        minCols: 2,
        maxCols: 5,
        minItemWidth: 260,
        gapCol: 16,
        gapRow: 80,
        fullBleed: readBool(grid.dataset.fullBleed, true),
        outerGutter: num(grid.dataset.outerGutter, 16),
        updateSizesAttr: true, // update <img sizes> for optimal srcset choice
        ...readDataset(grid),
        ...baseConfig,
      };

      grid.style.setProperty("--gap-col", `${cfg.gapCol}px`);
      grid.style.setProperty("--gap-row", `${cfg.gapRow}px`);
      grid.style.setProperty("--outer-gutter", `${cfg.outerGutter}px`);
      grid.dataset.fullBleed = String(!!cfg.fullBleed);

      const ro = new ResizeObserver(() => {
        // clientWidth includes padding; perfect for track calculation.
        const width = grid.clientWidth;
        if (!width) return;

        // How many columns fit at the *minimum* tile width?
        const colsByMin = Math.floor(
          (width + cfg.gapCol) / (cfg.minItemWidth + cfg.gapCol),
        );
        const cols = clamp(colsByMin, cfg.minCols, cfg.maxCols);

        grid.style.setProperty("--grid-cols", String(cols));

        // Optional: keep browser picking correct src from your <Picture> srcset.
        if (cfg.updateSizesAttr) {
          const trackWidth = (width - cfg.gapCol * (cols - 1)) / cols;
          // Update every img with .list-image inside the grid (works for <picture> too)
          grid
            .querySelectorAll("img.list-image")
            .forEach((img: HTMLImageElement) => {
              const px = Math.max(1, Math.round(trackWidth));
              if (img.sizes !== `${px}px`) img.sizes = `${px}px`;
            });
        }
      });

      ro.observe(grid);
      const parent = grid.parentElement;
      if (parent) ro.observe(parent);
    });

    function clamp(v: number, lo: number, hi: number): number {
      return Math.max(lo, Math.min(hi, v));
    }
    function num(v: string | undefined, fallback: number): number {
      const n = Number(v);
      return Number.isFinite(n) ? n : fallback;
    }
    function readBool(v: string | undefined, fallback: boolean): boolean {
      if (v == null) return fallback;
      return String(v).toLowerCase() === "true";
    }
    function readDataset(el: HTMLElement): Partial<GridConfig> {
      const d = el.dataset;
      const n = (x: string | undefined) => (x == null ? undefined : Number(x));
      return {
        minCols: n(d.minCols),
        maxCols: n(d.maxCols),
        minItemWidth: n(d.minItemWidth),
        gapCol: n(d.gapCol),
        gapRow: n(d.gapRow),
      };
    }
  }
  initGridSizer(".work-grid");
</script>
